SQLD 이론정리
#===============================================================================================================#
데이터 모델링

특징
추상화:현실세계를 간략히 표현
단순화: 누구나 쉽게 이해가능하도록 표현
명확성: 명확하게 의미가 해석되어야하고 한가지 의미를 가져야함

데이터모델링 단계
개념적모델링:전사적 관점에서 기업의 데이터 모델링
논리적모델링:개념적 모델링을 논리적 모델링으로 변환하는 작업
물리적모델링:데이터베이스를 실제로 구축하는것

관점
데이터 : 비즈니스 프로세스에서 사용되는 데이터
프로세스 : 비즈니스 프로세스에서 수행되는 작업
데이터와 프로세스 : 프로세스와 데이터간의 관계

데이터모델링을 위한 ERD
작성절차
1.엔티티 도출 및 그림
2.엔티티 배치
3.엔티티 간 관계 설정
4.관계명 서술
5,관계 참여도 표현
6.관계의 필수 여부 표현

데이터 모델링 고려사항
1.데이터 모델의 독립성
2.고객 요구사항의 표현
3.데이터 품질 확보
#===============================================================================================================#
3층 스키마
사용자 설계자 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관계를 정의한 ANSI 표준
데이터베이스이 독립성 확보위한 방법
독립성을 확보하면 데이터 복잡도 감소 데이터 중복제거 사용자 요구사항 변경에 따른 대응력향상 등의 장점
3단계 계층으로 분리해서 독립성 확보하는 방법으로 각계층을 뷰(VIEW)라고 한다

3층스키마 독립성
논리적 독립성 :개념 스키마 변경시 외부스키마가 영향 안받음
물리적 독립성 :내부 스키마 변경시 개념스키마가 영향 안받음


3층스키마 구조
외부스키마:응용프로그램이 접근하는 데이터베이스
개념스키마:통합 데이터베이스 구조
내부스키마:데이터 베이스 물리적 저장구조
#===============================================================================================================#
엔터티
업무에서 관리해야하는 데이터집합
개념 사건 장소등의 명사

특징
식별자 : 엔터티는 유일한 식별자가 있어야함
인스턴스 집합 : 2개이상의 인스턴스가 있어야함
속성 : 반드시 속성을 가지고있어야함
관계 : 다른 엔터티와 최소 한개이상 관계가 있어야함
업무 : 업무에서 관리되어야하는 집합

유무형에 따른 엔터티종류
유형:지속적으로 사용되는 엔티티
개념:유형엔티티는 물리적형태가 있지만 개념엔터티는 물리적 형태가 없음
사건:비즈니스 프로세스를 실행하면서 생성되는 엔터티

발생시점에 따른 엔터티종류
기본엔터티 : 키 엔터티,다른엔터티로부터 영향안받고 독립적으로 생성되는 엔터티
중심엔터티 : 기본엔터티와 행위엔터티 중간에있는것 -> 기본엔터티로부터 발생되고 행위 엔터티 생성
행위엔터티 : 2개 이상의 엔터티로부터 발생

#===============================================================================================================#
속성
업무에서 필요한 정보인 엔터티가 가지는 항목
더이상 분리되지 않는 단위,업무에 필요한 데이터 저장가능
인스턴스의 구성요소,의미적으로 더이상 분해되지않음

특징과 종류
특징
업무에서 관리되는 정보
하나의 값만 가짐
주식별자에게 함수적으로 종속,기본키 변경시 속성의 값도 변경

분해 여부에 따른 종류
단일속성 : 하나의 의미로 구성된것
복합속성 : 여러개의 의미가 있는것으로 대표적으로 주소가 있음
다중값속성 : 속성에 여러개의 값을 가질수있는것으로 대표적으로 상품리스트가있음

특성에 따른 속성의 종류
기본속성 : 비즈니스 프로세스에서 도출되는 본래 속성
설계속성 : 데이터 모델링 과정에서 발생하는 속성,유일한 값 부여
파생속성 : 다른 속성에 의해 만들어지는 속성

도메인 : 속성이 가질수있는 값의 범위

#===============================================================================================================#
관계
엔티티간의 관련성

종류
존재관계 : 엔티티간의 상태
행위관계 : 엔티티간의 어떤행위가 있는것

관계차수
두개의 엔티티간 관계에 참여하는 수

종류
1대1관계 
완전1대1관계 : 하나의 엔티티에 관계되는 엔티티의 관계가 하나인 경우로 반드시 존재
선택적1대1관계 : 하나의 엔티티에 관계되는 엔티티의 관계가 하나이거나 없을수있음

1대N관계
엔티티에 행이 하나 있을떄 다른 엔티티의 값이 여러개인 관계

M대N관계
두개의 엔티티가 서로 여러개의 관계를 가지고있는것
관계형 데이터베이스에서 M대N관계의 조인은 카테시안 곱이 발생 (카테시안곱? : From절에 2개 이상의 Table이 있을때 두 Table 사이에 유효 join 조건을 적지 않았을때 해당 테이블에 대한 모든 데이터를 전부 결합하여 Table에 존재하는 행 갯수를 곱한 만큼의 결과값이 반환되는 것)

필수적관계
반드시 하나가 있어야하는 관계

선택적 관계
없을수도있는 관계

식별관계와 비식별 관계
식별관계: 다른 엔티티에게 의존하지않고 독립적으로 존재하며 다른 엔티티와 관계를 가질떄 다른 엔티티에게 기본키를 공유하는 강한개체
비식별관계:강한개체의 기본키를 다른 엔티티의 기본키가 아닌 일반 칼럼으로  관계를 가지는것

강한개체:누구에게도 지배되지않는 독립적인 개체
약한개체:개체의 존재가 다른 개체의 존재에 달려있는 개체의

#===============================================================================================================#
엔티티 식별자
엔티티를 대표할수있는 유일성을 만족하는 속성

주식별자
최소성 : 최소성을 만족하는 키
대표성 : 엔터티를 대표할수있어야함
유일성 : 엔티티의 인스턴스를 유일하게 식별해야함
불변성 : 자주 변경되지 않아야함

키의 종류
기본키 : 후보키중 엔티티를 대표할수있는 키 
후보키 : 유일성과 최소성을 만족하는 키
슈퍼키 : 유일성은 만족하지만 최소성을 만족하지않는 키
대체키 : 여러개의 후보키중 기본키를 선정하고 남은 키
외래키 : 하나 혹은 다수의 다른테이블의 기본키 필드를 가리키는것, 참조 무결성을 확인하기 위해 사용되는 키 (허용된 데이터값만 데이터베이스에 저장하기 위해 사용됨)

식별자의 종류
대표성 여부에 따른 식별자 종류
주식별자 : 엔티티를 대표하는 식별자,다른엔티티와 참조관계로 연결가능
보조 식별자:대표성을 만족하지 못하는 식별자

생성 여부에 따른 식별자 종류
내부식별자 : 엔티티 내부에서 스스로 생성되는 식별자
외부식별자 : 다른엔티티와의 관계로 인해 만들어지는 식별자

속성의 수에 따른 식별자 종류
단일식별자 : 하나의 속성으로 구성된 식별자
복합식별자 : 두개 이상의 속성으로 구별된 식별자

대체 여부에 따른 식별자 종류
본질식별자 : 비즈니스 프로세스에서 만들어지는 식별자
인조식별자 : 인위적으로 만들어지는 식별자 (후보 식별자 중 주식별자로 선정할것이 없거나 주식별자의 칼럼이 너무 많을때 사용한다)
#===============================================================================================================#
데이터 모델과 성능
정규화 
데이터의 일관성,최소한의 데이터 중복,최대한의 데이터의 유연성을 위한 방법이며 데이터를 분해하는 과정
데이터 중복 제거하고 데이터모델의 독립성을 확보하기위한 방법
테이블을 분해해서 데이터 중복을 제거하기때문에 데이터 모델의 유연성을 높인다
비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할수있다
제1정규화부터 제5정규화까지 있지만 실질적으로는 제3정규화까지만 실행한다

이상현상:테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상

정규화절차
제1정규화 : 속성의 원자성을 확보,기본키를 설정
정규화는 함수적 종속성을 근거로 함 
ex)X키가 변화하면 Y테이블도 변화한다 이러한 경우 X키가 Y테이블을 함수적으로 종속시킨다볼수있다 (이러한 경우 X키를 기본키로 설정한다)

제2정규화 : 기본키가 2개이상의 속성으로 이루어진경우 부분함수 종속성을 제거한다
ex)X키가 변화하면 Y테이블의 특정키가 변경된다 이러한 경우 X키가 Y테이블의 특정키를 함수적으로 종속시킨다볼수있다 (이러한 경우 테이블을 분해해야한다)
테이블을 분해하면 X키 그리고 X키와 함수적으로 종속된 키가 분해되어 새로운 테이블이 도출된다 
(함수적으로 종속되어있는 키는 기존테이블에서 분해되고 종속시키는 키는 복사되어 새로운 테이블을 도출한다 이러한 경우 종속시키는 키가 기본키가 된다)

제3정규화 : 기본키를 제외한  칼럼간의 종속성 제거,이행함수종속성 제거
기본키를 제외한 나머지 칼럼간에 종속성이 발생하는 경우를 이행함수종속성이라고 한다 ex)관리점과 관리점코드
제3정규화는 제1정규화와 제2정규화를 수행한 다음 수행해야한다
제3정규화를 진행하면 종속되어있는키와 종속시키는 키가 분해되어나오며 종속시키는 키가 기본키가 된다 ex) 관리점코드(기본키)->관리점

BCNF : 기본키를 제외하고 후보키가 있는경우 후보키가 기본키를 종속시키면 분해해야한다
복수의 후보키가 있고 후보키들이 복합속성이어야하며 서로 중첩되어야한다


제4정규화 : 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다
제5정규화 : 조인에 의해서 종속성이 발생되는 경우 분해한다

정규화의 문제점
데이터 조회시 조인을 유발하기때문에 CPU와 메모리를 많이 사용한다
정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인으로 인한 성능저하는 해결될것이다 (반정규화)
반정규화는 데이터를 중복시키기 때문에 또 다른 문제 야기
#===============================================================================================================#
반정규화
데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능향상 방법
데이터 조회속도를 향상시키지만 데이터 모델의 유연성은 낮아진다

반정규화를 수행하는 경우
정규화에 충실하면 종속성,활용성은 향상되지만 수행속도가 느려질때
다량의 범위를 자주 처리해야하는 경우
특정 범위의 데이터만 자주 처리하는 경우
요약/집계 정보가 자주 요구되는 경우

절차
대상 조사 및 검토 : 데이터처리범위,통계성 등 확인후 반정규화 대상 조사
다른 방법 검토 : 클러스터링뷰,인덱스튜닝,응용프로그램,파티션 등 다른 방법 검토
반정규화 수행 : 테이블 속성,관계 등 반정규화 진행

반정규화 기법
계산된칼럼 추가 : 배치프로그램으로 미리 계산후 결과를 특정 칼럼에 추가하는 기법
테이블 수직분할 : 하나의 테이블을 두개 이상의 테이블로 분할 (칼럼을 분해하여 새로운 테이블 만드는것)
테이블 수평분할 : 하나의 테이블에 있는 값으로 테이블을 분할하는 방법

파티션기법:논리적으로는 하나의 테이블이지만 여러개의 데이터파일에 분산되어 저장하는 기법
종류
Range : 데이터 값 범위 기준으로 파티션 수행
List : 특정값 지정하여 수행
Hash : 해시 함수 적용 
Composite : 범위와 해시를 복합적으로 사용됨

장점:데이터조회시 엑세스 범위가 줄어들기에 성능향상,데이터가 분할되어있기 때문에 입출력의 성능이 향상됨,각 파티션을 독립적으로 백업 및 복구 가능

테이블 병합
1대1관계 테이블 -> 하나의 테이블로 병합하여 성능향상
1대 N 관계 테이블을 병합하여 성능향상 -> 하지만 많은 양의 데이터 중복이 발생
슈퍼타입과 서브 타입관계 발생시 테이블을 통합하여 성능 향상

Super Type (부모)
Sub Type (자식)
슈퍼타입,서브타입 변환방법
OneToOne : 슈퍼 타입과 서브타입을 개별테이블로 도출,테이블수가 많아서 조인이 많이 발생하고 관리가 어려움
PlusType: 슈퍼타입과 서브타입 테이블로 도출,조인이 발생하고 관리가 어려움
SingleType : 슈퍼타입과 서브타입을 하나의 테이블로 도출,조인성능이 좋고 관리가 편하지만 입출력성능이 나쁨

#===============================================================================================================#
분산 데이터 베이스

데이터베이스의 구조
중앙 집중형 데이터베이스 :  한대의 물리적 시스템에 데이터베이스 관리시스템을 설치하고 다른 사용자가 데이터베이스관리시스템에 접속하여 데이터베이스를 사용하는 방식
분산 데이터 베이스:물리적으로 떨어진 데이터베이스를 데이터베이스 네트워크로 연결하여 단일 데이터베이스로 보여주고 분산작업처리를 수행하는 데이터베이스 운용 방식

분산데이터베이스의 투명성
시스템이 네트워크로 분산되어있는지 여부를 알지못하게하면서 자신만의 데이터베이스를 사용하는것처럼하는 방식 

투명성의 종류
분할 투명성 : 각 단편의 사본이 여러 시스템에 저장되어있는지 모르게함
위치 투명성 : 고객이 사용하는 데이터의 저장장소를 모르게함
지역 사상 투명성 : 지역DBMS와 물적 데이터베이스 사이 사상이 보장됨에 따라 각 지역 시스템이름과 무관한 이름이 사용가능함
중복 투명성 : 데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지되는것
장애 투명성 : 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생하도 데이터의 무결성이 보장되는것
병행 투명성 : 여러 고객의 응용프로그램이 동시에 분산데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없는것

분산데이터베이스 설계 방식
상향식 설계방식
지역 스키마 작성후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축하는것

하향식 설계방식
전역 스키마 작성후 해당지역 사상 스키마를 작성하여 분산데이터베이스를 구축하는것

분산 데이터베이스의 장단점
장점
데이터베이스 신뢰성과 가용성이 높음
병렬처리를 수행하기에 빠른 응답 가능
분산데이터베이스 추가하여 시스템 용량 확장이 쉬움

단점
관리와 통제가 어려움
보안관리가 어려움
데이터 무결성 관리가 어려움
설계가 복잡하다

























